name: Bootstrap Community

on:
  push:
    branches: [main]
    paths:
      - ".github/workflows/bootstrap-community.yml"
      - ".github/seed/**"
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  seed:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Seed labels and roadmap issues
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require("fs");
            const seedDir = ".github/seed";
            const files = fs.readdirSync(seedDir).filter((f) => f.endsWith(".json"));

            const labelsByName = new Map();
            const issues = [];
            for (const file of files) {
              const raw = fs.readFileSync(`${seedDir}/${file}`, "utf8");
              const seed = JSON.parse(raw);
              for (const label of (seed.labels || [])) {
                labelsByName.set(label.name, label);
              }
              for (const issue of (seed.issues || [])) {
                issues.push(issue);
              }
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function upsertLabel(label) {
              try {
                await github.rest.issues.getLabel({
                  owner, repo, name: label.name
                });
                await github.rest.issues.updateLabel({
                  owner, repo,
                  name: label.name,
                  new_name: label.name,
                  color: label.color,
                  description: label.description
                });
                core.info(`Updated label: ${label.name}`);
              } catch (err) {
                if (err.status === 404) {
                  await github.rest.issues.createLabel({
                    owner, repo,
                    name: label.name,
                    color: label.color,
                    description: label.description
                  });
                  core.info(`Created label: ${label.name}`);
                } else {
                  throw err;
                }
              }
            }

            async function fetchExistingIssueTitles() {
              const issuesByTitle = new Map();
              let page = 1;
              while (true) {
                const res = await github.rest.issues.listForRepo({
                  owner,
                  repo,
                  state: "all",
                  per_page: 100,
                  page
                });
                if (res.data.length === 0) {
                  break;
                }
                for (const item of res.data) {
                  if (!item.pull_request) {
                    issuesByTitle.set(item.title.trim(), item);
                  }
                }
                if (res.data.length < 100) {
                  break;
                }
                page += 1;
              }
              return issuesByTitle;
            }

            for (const label of labelsByName.values()) {
              await upsertLabel(label);
            }

            const existingIssues = await fetchExistingIssueTitles();

            for (const issue of issues) {
              const normalizedTitle = issue.title.trim();
              if (existingIssues.has(normalizedTitle)) {
                const existing = existingIssues.get(normalizedTitle);
                const currentLabels = (existing.labels || []).map((l) =>
                  typeof l === "string" ? l : l.name
                );
                const mergedLabels = [...new Set([...currentLabels, ...(issue.labels || [])])];

                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: existing.number,
                  labels: mergedLabels
                });
                core.info(`Synced labels for existing issue: ${issue.title}`);
                continue;
              }
              const created = await github.rest.issues.create({
                owner,
                repo,
                title: issue.title,
                body: issue.body,
                labels: issue.labels
              });
              existingIssues.set(normalizedTitle, created.data);
              core.info(`Created issue: ${issue.title}`);
            }
